/**
 * This class has been generated by Fast Code Eclipse Plugin
 * For more information please go to http://fast-code.sourceforge.net/
 * @author : Biswarup
 * Created : 09/08/2014 04:08:51
 */
package org.fastcode.handler;

import static org.fastcode.common.FastCodeConstants.COLON;
import static org.fastcode.common.FastCodeConstants.COMMA;
import static org.fastcode.common.FastCodeConstants.EMPTY_STR;
import static org.fastcode.common.FastCodeConstants.FC_OBJ_CREATED;
import static org.fastcode.common.FastCodeConstants.FIELD_ANNOTATIONS_STR;
import static org.fastcode.common.FastCodeConstants.FIELD_CLASS_STR;
import static org.fastcode.common.FastCodeConstants.FIELD_MODIFIER_STR;
import static org.fastcode.common.FastCodeConstants.FIELD_NAME_STR;
import static org.fastcode.common.FastCodeConstants.HASH;
import static org.fastcode.common.FastCodeConstants.MODIFIER_PRIVATE;
import static org.fastcode.common.FastCodeConstants.OPTIONAL;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_FIELDS;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_NAME;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_PROJECT;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_TARGET;
import static org.fastcode.common.FastCodeConstants.SPACE;
import static org.fastcode.common.FastCodeConstants.TEMPLATE_TAG_PREFIX;
import static org.fastcode.common.FastCodeConstants.XML_START;
import static org.fastcode.util.SourceUtil.doesFieldExistsInType;
import static org.fastcode.util.SourceUtil.getJavaProject;
import static org.fastcode.util.SourceUtil.getWorkingJavaProjectFromUser;
import static org.fastcode.util.StringUtil.format;
import static org.fastcode.util.StringUtil.isEmpty;
import static org.fastcode.util.StringUtil.isJavaReservedWord;
import static org.fastcode.util.StringUtil.isValidVariableName;
import static org.fastcode.util.StringUtil.parseFieldName;
import static org.fastcode.util.StringUtil.replacePlaceHolders;
import static org.fastcode.util.VersionControlUtil.isPrjConfigured;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IField;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IMember;
import org.eclipse.jdt.core.IType;
import org.fastcode.common.Action;
import org.fastcode.common.FastCodeConstants.ACTION_ENTITY;
import org.fastcode.common.FastCodeConstants.ACTION_TYPE;
import org.fastcode.common.FastCodeConstants.TARGET;
import org.fastcode.common.FastCodeConstants.TemplateTag;
import org.fastcode.common.FastCodeEntityHolder;
import org.fastcode.common.FastCodeField;
import org.fastcode.common.FastCodeObject;
import org.fastcode.common.FastCodeProject;
import org.fastcode.common.FastCodeType;
import org.fastcode.exception.FastCodeRepositoryException;
import org.fastcode.popup.actions.snippet.TemplateTagsProcessor;
import org.fastcode.preferences.VersionControlPreferences;
import org.fastcode.setting.GlobalSettings;

public class FCFieldTagHandler implements FCTagHandler {

	@Override
	public Action populateTagAction(final TemplateTag tagFound, final String tagBody, String insideTagBody,
			final ICompilationUnit compUnit, final boolean hasSubAction1, final Map<String, Object> placeHolders,
			final Map<String, Object> contextMap, final String spacesBeforeCursor, final Map<String, String> attributes,
			final StringBuilder existingMembersBuilder, final List<Action> actionList) throws Exception {
		String memberName = null;
		String targetClass = null;
		boolean optional = false;
		final ACTION_TYPE actionType = ACTION_TYPE.Create;
		String imprt = null;
		/*
		 * if (compUnit.getJavaProject().getProject().isSynchronized(0)) {
		 * throw new Exception("Project: " +
		 * compUnit.getJavaProject().getProject().getName() +
		 * " is not synchronized ,Please refresh and try again."); }
		 */

		if (!isEmpty(insideTagBody) && insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON)) {
			throw new Exception("There should not be any other tags inside <fc:field>,  exiting....");
		}
		Action actionField = null;
		memberName = attributes.containsKey(PLACEHOLDER_NAME) ? attributes.get(PLACEHOLDER_NAME) : null;
		targetClass = attributes.containsKey(TARGET.clas.getValue()) ? attributes.get(TARGET.clas.getValue()) : null;
		if (targetClass == null) {
			targetClass = attributes.containsKey(PLACEHOLDER_TARGET) ? attributes.get(PLACEHOLDER_TARGET) : null;
		}
		optional = attributes.containsKey(OPTIONAL) ? Boolean.valueOf(attributes.get(OPTIONAL)) : false;
		final String fieldType = attributes.containsKey("fieldClass") ? attributes.get("fieldClass") : null;

		imprt = attributes.containsKey("import") ? attributes.get("import") : null;

		IJavaProject javaProj1 = null;
		if (compUnit == null) {
			final FastCodeProject codeProject = (FastCodeProject) placeHolders.get(PLACEHOLDER_PROJECT);
			if (codeProject.getJavaProject() != null) {
				javaProj1 = codeProject.getJavaProject();
			}
		} else {
			javaProj1 = compUnit.getJavaProject();
		}

		if (javaProj1 == null) {
			throw new Exception("<fc:field> tag works only on Java classes.");
		}
		//final FastCodeType tgtFCType = null;

		final List<String> classToImportList1 = new ArrayList<String>();
		if (!isEmpty(imprt)) {
			for (final String clasToImport : imprt.split(SPACE)) {
				classToImportList1.add(clasToImport);
			}
			for (final String clasToImport : imprt.split(SPACE)) {
				final FCImportTagHandler importTagHandler = new FCImportTagHandler();
				final IType type2 = importTagHandler.validateClassToImport(clasToImport, clasToImport, compUnit);
				if (type2 == null) {
					classToImportList1.remove(clasToImport);
				}
			}
			String importNames = EMPTY_STR;
			if (!classToImportList1.isEmpty()) {
				for (final String importName : classToImportList1) {
					importNames = importNames + importName + SPACE;

				}
				imprt = importNames;
			}
		}
		if (memberName == null || memberName.equals(EMPTY_STR)) {
			throw new Exception("Please provide attribute \"name\" for <fc:field> tag in the XML and try again");
		} else if (isJavaReservedWord(memberName) || !isValidVariableName(memberName)) {
			throw new Exception(
					"Attribute \"name\" contains either java reserve word or not valid for field name ,Please provide correct one  for <fc:field> tag  in the XML and try again");
		}

		if (compUnit == null && isEmpty(targetClass)) {
			throw new Exception(
					"This template needs Java class to be open in the editor. Compilation unit is null (no java class open in the editor) and there is no target class. Field cannot be created");
		}
		FastCodeType fastCodeType = null;
		boolean createTargetClass1 = false;
		/*IJavaProject javaProj1 = null;
			if (compUnit == null) {
				FastCodeProject codeProject = ((FastCodeProject) placeHolders.get(PLACEHOLDER_PROJECT));
				if (codeProject.getJavaProject() != null) {
					javaProj1 = codeProject.getJavaProject();
				}
			} else {
				javaProj1 = compUnit.getJavaProject();
			}*/
		if (!isEmpty(targetClass)) {
			//have to check if class is there in placeholder
			fastCodeType = targetClass.startsWith(HASH) ? (FastCodeType) placeHolders.get(targetClass.replace(HASH, EMPTY_STR).trim())
					: new FastCodeType(javaProj1.findType(targetClass.trim()));
			if (fastCodeType.getiType() == null) {
				//have to put code for creating the class

				createTargetClass1 = true;
				fastCodeType = new FastCodeType(targetClass);

			}
		} else {
			fastCodeType = new FastCodeType(compUnit.findPrimaryType());
		}
		final TemplateTagsProcessor templateTagsProcessor = new TemplateTagsProcessor();
		if (!createTargetClass1) {
			templateTagsProcessor.validateTargetClassType(targetClass, fastCodeType.getiType());

			if (doesFieldExistsInType(fastCodeType.getiType(), memberName)) {
				existingMembersBuilder.append("Field with Name:  " + memberName);
				existingMembersBuilder.append(SPACE + COMMA + SPACE);
				return null;
			}
		}
		if (isEmpty(insideTagBody)) {
			final String fieldType1 = attributes.containsKey("fieldType") ? attributes.get("fieldType") : "Object";
			final String modifier = attributes.containsKey("modifier") ? attributes.get("modifier") : MODIFIER_PRIVATE;
			insideTagBody = buildFieldSrc(fieldType1, modifier, memberName);
			if (isEmpty(insideTagBody)) {
				throw new Exception(
						"There is no details of field inside fc:field tag body and There is no attributes like fieldType,modifier.Please provide field details and try again?");
			}
		}
		final String fieldNameInsideTagBody = parseFieldName(insideTagBody.trim());
		if (!memberName.equals(fieldNameInsideTagBody)) {
			throw new Exception("Attribute \"name\" value " + memberName + " and field name inside <fc:field> tag body "
					+ fieldNameInsideTagBody
					+ " does not match, Please provide same name in both the places for <fc:field> tag  in the XML and try again");
		}
		actionField = new Action.Builder()
				.withEntity(ACTION_ENTITY.Field)
				.withType(actionType)
				.withEntityName(memberName)
				.withTarget(fastCodeType)
				.withSource(isEmpty(insideTagBody) ? insideTagBody : insideTagBody.trim())
				.withLabelMsg(
						createTargetClass1 ? "Create class " + targetClass + " and " + actionType.toString() + " Field  " + memberName
								+ " in " + targetClass : actionType.toString() + " Field  " + memberName + "  in class  "
								+ fastCodeType.getName()).withOptional(optional).withClassToImport(fieldType).withImports(imprt)
				.withSubAction(templateTagsProcessor.getSubActions()).build();
		return actionField;
	}

	/**
	 * @param fieldType1
	 * @param modifier
	 * @param memberName
	 * @return
	 * @throws Exception
	 */
	private String buildFieldSrc(final String fieldType1, final String modifier, final String memberName) throws Exception {
		final GlobalSettings globalSettings = GlobalSettings.getInstance();
		final Map<String, Object> placeHoldersForField = new HashMap<String, Object>();
		final String fieldBody = globalSettings.getFieldBody().trim();

		placeHoldersForField.put(FIELD_CLASS_STR, fieldType1);
		placeHoldersForField.put(FIELD_NAME_STR, memberName);
		placeHoldersForField.put(FIELD_MODIFIER_STR, modifier);
		placeHoldersForField.put(FIELD_ANNOTATIONS_STR, EMPTY_STR);
		final String fieldSrc = replacePlaceHolders(fieldBody, placeHoldersForField);
		return fieldSrc;
	}

	/**
	 * @param fieldName
	 * @param fieldSource
	 * @param targetFastCodeType
	 * @param classToImport
	 * @param imports
	 * @param contextMap
	 * @param spacesBeforeCursor
	 * @param placeHolders
	 * @param compUnit
	 * @return
	 * @throws Exception
	 */
	public IMember createFieldFromTag(final String fieldName, final String fieldSource, final FastCodeType targetFastCodeType,
			final String classToImport, final String imports, final Map<String, Object> contextMap, final String spacesBeforeCursor,
			final Map<String, Object> placeHolders, final ICompilationUnit compUnit) throws Exception {
		/*if (!isEmpty(imports)) {
			for (String clasToImport : imports.split(SPACE)) {
				createImportFromTag(clasToImport, compUnit);
			}
		}*/
		IType type = null;
		final VersionControlPreferences versionControlPreferences = VersionControlPreferences.getInstance();
		if (targetFastCodeType.getiType() == null) {
			IJavaProject javaProject = null;
			if (javaProject == null) {
				javaProject = getJavaProject(placeHolders.get(PLACEHOLDER_PROJECT) instanceof FastCodeProject ? ((FastCodeProject) placeHolders
						.get(PLACEHOLDER_PROJECT)).getName() : (String) placeHolders.get(PLACEHOLDER_PROJECT));
			}

			if (javaProject == null) {
				javaProject = getWorkingJavaProjectFromUser();//did for j2ee base
			}
			final FCClassTagHandler fcClassTagHandler = new FCClassTagHandler();
			fcClassTagHandler.createClassFromTag(targetFastCodeType.getName(), targetFastCodeType.getPackage().getName(), null, EMPTY_STR,
					contextMap, placeHolders, null, "class", spacesBeforeCursor, false, false, false);
			type = ((ICompilationUnit) ((FastCodeObject) contextMap.get("Class_" + targetFastCodeType.getName() + ".java")).getObject())
					.findPrimaryType();
		} else {
			type = targetFastCodeType.getiType();
		}
		final FCImportTagHandler importTagHandler = new FCImportTagHandler();
		if (!isEmpty(imports)) {
			for (final String clasToImport : imports.split(SPACE)) {
				importTagHandler.createImportFromTag(clasToImport, compUnit != null ? compUnit : type.getCompilationUnit());
			}
		}
		type.getCompilationUnit().becomeWorkingCopy(null);
		format(fieldSource, spacesBeforeCursor);

		if (!isEmpty(classToImport)) {
			importTagHandler.createImportFromTag(classToImport, type.getCompilationUnit());
		}
		final IField field = type.createField(fieldSource, null, false, new NullProgressMonitor());

		if (field == null || !field.exists()) {
			type.getCompilationUnit().discardWorkingCopy();
			throw new Exception("Unable to create field.");
		}

		try {
			final boolean prjShared = !isEmpty(type.getResource().getProject().getPersistentProperties());
			final boolean prjConfigured = !isEmpty(isPrjConfigured(type.getResource().getProject().getName()));
			if (versionControlPreferences.isEnable() && prjShared && prjConfigured) {
				final IFile file = (IFile) type.getResource(); //.getLocationURI();
				List<FastCodeEntityHolder> chngesForType = ((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED))
						.get(file);
				if (chngesForType == null) {
					chngesForType = new ArrayList<FastCodeEntityHolder>();
					final List<Object> fastCodeFieldList = new ArrayList<Object>();
					fastCodeFieldList.add(new FastCodeField(field));
					chngesForType.add(new FastCodeEntityHolder(PLACEHOLDER_FIELDS, fastCodeFieldList));
				} else {
					boolean isNew = true;
					Object fastCodeFieldList = null;
					for (final FastCodeEntityHolder fcEntityHolder : chngesForType) {
						if (fcEntityHolder.getEntityName().equals(PLACEHOLDER_FIELDS)) {
							fastCodeFieldList = fcEntityHolder.getFastCodeEntity();
							isNew = false;
							break;
						}
					}

					if (isNew) {
						fastCodeFieldList = new ArrayList<Object>();
						((List<Object>) fastCodeFieldList).add(new FastCodeField(field));
						chngesForType.add(new FastCodeEntityHolder(PLACEHOLDER_FIELDS, fastCodeFieldList));
					} else {
						((List<Object>) fastCodeFieldList).add(new FastCodeField(field));
					}
				}
				((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED)).put(file, chngesForType);
			}
		} catch (final FastCodeRepositoryException ex) {
			ex.printStackTrace();
		}
		type.getCompilationUnit().commitWorkingCopy(false, null);
		type.getCompilationUnit().discardWorkingCopy();
		return field;
	}
}
