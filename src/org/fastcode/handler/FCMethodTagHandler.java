/**
 * This class has been generated by Fast Code Eclipse Plugin
 * For more information please go to http://fast-code.sourceforge.net/
 * @author : Biswarup
 * Created : 09/08/2014 04:08:51
 */
package org.fastcode.handler;

import static org.fastcode.common.FastCodeConstants.AUTO_CHECKIN;
import static org.fastcode.common.FastCodeConstants.BOOLEAN;
import static org.fastcode.common.FastCodeConstants.COLON;
import static org.fastcode.common.FastCodeConstants.COMMA;
import static org.fastcode.common.FastCodeConstants.DOUBLE;
import static org.fastcode.common.FastCodeConstants.EMPTY_STR;
import static org.fastcode.common.FastCodeConstants.FC_OBJ_CREATED;
import static org.fastcode.common.FastCodeConstants.FLOAT;
import static org.fastcode.common.FastCodeConstants.HASH;
import static org.fastcode.common.FastCodeConstants.INT;
import static org.fastcode.common.FastCodeConstants.LEFT_CURL;
import static org.fastcode.common.FastCodeConstants.METHOD_ANNOTATIONS_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_ARGS_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_BODY_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_COMMENTS_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_EXCEPTIONS_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_MODIFIER_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_NAME_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_RETURN_TYPE_STR;
import static org.fastcode.common.FastCodeConstants.METHOD_RETURN_TYPE_VOID;
import static org.fastcode.common.FastCodeConstants.MODIFIER_PUBLIC;
import static org.fastcode.common.FastCodeConstants.OPTIONAL;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_METHODS;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_NAME;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_PROJECT;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_TARGET;
import static org.fastcode.common.FastCodeConstants.RIGHT_CURL;
import static org.fastcode.common.FastCodeConstants.SPACE;
import static org.fastcode.common.FastCodeConstants.TEMPLATE_TAG_PREFIX;
import static org.fastcode.common.FastCodeConstants.TYPE;
import static org.fastcode.common.FastCodeConstants.XML_START;
import static org.fastcode.popup.actions.snippet.TemplateTagsProcessor.proceedWithAutoCheckin;
import static org.fastcode.util.SourceUtil.getJavaProject;
import static org.fastcode.util.SourceUtil.getWorkingJavaProjectFromUser;
import static org.fastcode.util.StringUtil.format;
import static org.fastcode.util.StringUtil.getGlobalSettings;
import static org.fastcode.util.StringUtil.isEmpty;
import static org.fastcode.util.StringUtil.isJavaReservedWord;
import static org.fastcode.util.StringUtil.isValidVariableName;
import static org.fastcode.util.StringUtil.parseMethodName;
import static org.fastcode.util.StringUtil.replacePlaceHolderWithBlank;
import static org.fastcode.util.StringUtil.replacePlaceHolders;
import static org.fastcode.util.StringUtil.replaceSpecialChars;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.fastcode.common.Action;
import org.fastcode.common.FastCodeConstants.ACTION_ENTITY;
import org.fastcode.common.FastCodeConstants.ACTION_TYPE;
import org.fastcode.common.FastCodeConstants.TARGET;
import org.fastcode.common.FastCodeConstants.TemplateTag;
import org.fastcode.common.FastCodeEntityHolder;
import org.fastcode.common.FastCodeMethod;
import org.fastcode.common.FastCodeObject;
import org.fastcode.common.FastCodeProject;
import org.fastcode.common.FastCodeType;
import org.fastcode.exception.FastCodeRepositoryException;
import org.fastcode.popup.actions.snippet.TemplateTagsProcessor;
import org.fastcode.setting.GlobalSettings;

public class FCMethodTagHandler implements FCTagHandler {

	@Override
	public Action populateTagAction(final TemplateTag tagFound, final String tagBody, final String insideTagBody,
			final ICompilationUnit compUnit, final boolean hasSubAction1, final Map<String, Object> placeHolders,
			final Map<String, Object> contextMap, final String spacesBeforeCursor, final Map<String, String> attributes,
			final StringBuilder existingMembersBuilder, final List<Action> actionList) throws Exception {
		String memberName = null;
		String targetClass = null;
		String memberSource = null;
		boolean optional = false;
		final ACTION_TYPE actionType = ACTION_TYPE.Create;
		String typeToCreate = null;
		String classToImport = null;
		/*
		 * if (compUnit.getJavaProject().getProject().isSynchronized(0)) {
		 * throw new Exception("Project: " +
		 * compUnit.getJavaProject().getProject().getName() +
		 * " is not synchronized ,Please refresh and try again."); }
		 */

		Action actionMethod = null;
		memberName = attributes.containsKey(PLACEHOLDER_NAME) ? attributes.get(PLACEHOLDER_NAME) : null;
		if (memberName == null || memberName.equals(EMPTY_STR)) {
			throw new Exception("Please provide \"name\" attribute for <fc:method> tag  in the XML and try again");
		} else if (isJavaReservedWord(memberName) || !isValidVariableName(memberName)) {
			throw new Exception(
					"Attribute \"name\" contains either java reserve word or not valid for method name ,Please provide correct one  for <fc:method> tag  in the XML and try again");
		}
		targetClass = attributes.containsKey(TARGET.clas.getValue()) ? attributes.get(TARGET.clas.getValue()) : null;
		if (targetClass == null) {
			targetClass = attributes.containsKey(PLACEHOLDER_TARGET) ? attributes.get(PLACEHOLDER_TARGET) : null;
		}
		optional = attributes.containsKey(OPTIONAL) ? Boolean.valueOf(attributes.get(OPTIONAL)) : false;
		typeToCreate = attributes.containsKey(TYPE) ? attributes.get(TYPE) : null;
		classToImport = attributes.containsKey("import") ? attributes.get("import") : null;

		if (compUnit == null && isEmpty(targetClass)) {
			throw new Exception(
					"<fc:method> needs Java class to be open in the editor. Compilation unit is null (no java class open in the editor) and there is no target class. Method cannot be created");
		}
		FastCodeType codeType = null;
		IType type1 = null;
		boolean createTargetClass = false;
		IJavaProject javaProj = null;
		if (compUnit == null) {
			final FastCodeProject codeProject = (FastCodeProject) placeHolders.get(PLACEHOLDER_PROJECT);
			if (codeProject.getJavaProject() != null) {
				javaProj = codeProject.getJavaProject();
			}
		} else {
			javaProj = compUnit.getJavaProject();
		}

		if (javaProj == null) {
			throw new Exception("<fc:method> tag works only on Java classes.");
		}
		final List<String> classToImportList = new ArrayList<String>();

		if (!isEmpty(classToImport)) {
			for (final String clasToImport : classToImport.split(SPACE)) {
				classToImportList.add(clasToImport);
			}
			for (final String clasToImport : classToImport.split(SPACE)) {
				final FCImportTagHandler fcTagHandler = new FCImportTagHandler();
				final IType type2 = fcTagHandler.validateClassToImport(clasToImport, clasToImport, compUnit);
				if (type2 == null) {
					classToImportList.remove(clasToImport);
				}
			}
			String importNames = EMPTY_STR;
			if (!classToImportList.isEmpty()) {
				for (final String importName : classToImportList) {
					importNames = importNames + importName + SPACE;

				}
				classToImport = importNames;
			}
		}

		if (!isEmpty(targetClass)) {
			//have to check if class is there in placeholder
			codeType = targetClass.startsWith(HASH) ? (FastCodeType) placeHolders.get(targetClass.replace(HASH, EMPTY_STR).trim())
					: new FastCodeType(javaProj.findType(targetClass.trim()));
			if (codeType.getiType() == null) {
				//have to put code for creating the class

				createTargetClass = true;
				codeType = new FastCodeType(targetClass);

			}
		} else {
			codeType = new FastCodeType(compUnit.findPrimaryType());
		}
		boolean hasSubAction = false;
		if (!isEmpty(insideTagBody) && insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Import.getValue())) {
			/*if (!isEmpty(imprt)) {
				throw new Exception("There can be either attribute \"import\" or <fc:import> tag inside <fc:method>,  exiting....");
			}*/
			hasSubAction = true;
		} else if (insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Method.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Field.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.File.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Class.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Folder.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Xml.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Message.getValue())
				|| insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON + ACTION_ENTITY.Exit.getValue())) {
			throw new Exception("There should not be any other tags inside <fc:method> except <fc:import>,  exiting....");
		}
		if (hasSubAction && createTargetClass) {
			throw new Exception("Target class does not exist and there is fc:import inside fc:method tag body.Cant proceed further");
		}
		//final IType type1 = targetClass == null ? compUnit.findPrimaryType() : compUnit.getJavaProject().findType(targetClass.trim());
		final TemplateTagsProcessor templateTagsProcessor = new TemplateTagsProcessor();
		if (!createTargetClass) {
			type1 = codeType.getiType();
			templateTagsProcessor.validateTargetClassType(targetClass, type1);
		}

		memberSource = hasSubAction && !createTargetClass ? templateTagsProcessor.processTemplateTags(type1.getCompilationUnit(),
				insideTagBody, null, hasSubAction, null, null) : insideTagBody;

		hasSubAction = false;

		if (isEmpty(memberSource)) {

			final String returnType = attributes.containsKey("returnType") ? attributes.get("returnType") : METHOD_RETURN_TYPE_VOID;
			final String parameters = attributes.containsKey("parameters") ? attributes.get("parameters") : EMPTY_STR;
			final String modifier = attributes.containsKey("modifier") ? attributes.get("modifier") : MODIFIER_PUBLIC;
			memberSource = buildMemberSrc(memberName, returnType, parameters, modifier, type1);
			if (isEmpty(memberSource)) {
				throw new Exception(
						"There is no details of method inside fc:method tag body and There is no attributes like returnType,parameters,modifiers.Please provide method details and try again");
			}
		}

		final String methodNameInsideTagbody = parseMethodName(replaceSpecialChars(memberSource.trim()));
		if (!memberName.equals(methodNameInsideTagbody)) {
			throw new Exception("Attribute \"name\" value " + memberName + " and method name inside <fc:method> tag body "
					+ methodNameInsideTagbody
					+ " does not match, Please provide same name in both the places for <fc:method> tag  in the XML and try again");
		}
		if (!createTargetClass) {
			boolean exist = false;
			for (final IMethod method : type1.getMethods()) {
				if (method.getElementName().equals(memberName)) {
					final IMethod newMethod = type1.getMethod(memberName, method.getParameterTypes());
					exist = newMethod != null && newMethod.exists();
				}

			}
			if (exist) {
				existingMembersBuilder.append("Method with name: " + memberName);
				existingMembersBuilder.append(SPACE + COMMA + SPACE);
				return null;
			}
			String methodBody = null;
			if (memberSource.contains(LEFT_CURL) && memberSource.contains(RIGHT_CURL)) {
				methodBody = memberSource.substring(memberSource.indexOf(LEFT_CURL) + 1, memberSource.lastIndexOf(RIGHT_CURL));
			}
			if (type1.isInterface() && !isEmpty(methodBody)) {
				throw new Exception(
						"Target class: "
								+ type1.getFullyQualifiedName()
								+ "   specified in the XML is an interface and method has method body.Can not create this method in an interface.Please choose another class");
			}
		}
		final String partLblMsg1 = typeToCreate == null ? "class " : typeToCreate;
		final String partLblMsg2 = typeToCreate == null ? EMPTY_STR : typeToCreate;

		actionMethod = new Action.Builder()
				.withEntityName(memberName)
				.withTarget(codeType)
				.withType(actionType)
				.withEntity(ACTION_ENTITY.Method)
				.withSource(isEmpty(memberSource) ? memberSource : memberSource.trim())
				.withSubAction(templateTagsProcessor.getSubActions())
				.withLabelMsg(
						createTargetClass ? "Create " + partLblMsg1 + " class " + targetClass + " and " + actionType.toString()
								+ partLblMsg2 + " Method   " + memberName + " in " + targetClass : actionType.toString() + partLblMsg2
								+ " Method   " + memberName + "  in class  " + type1.getElementName()).withOptional(optional)
				.withTypeToCreate(typeToCreate).withImports(classToImport)
				/*.withExist(exist)*/.build();
		return actionMethod;
	}

	/**
	 * @param memberName
	 * @param returnType
	 * @param parameters
	 * @param modifier
	 * @param type1
	 * @return
	 * @throws Exception
	 */
	private String buildMemberSrc(final String memberName, final String returnType, final String parameters, final String modifier,
			final IType type1) throws Exception {
		final GlobalSettings globalSettings = GlobalSettings.getInstance();
		final Map<String, Object> placeHoldersForMethod = new HashMap<String, Object>();
		String fullMethodPattern = EMPTY_STR;
		placeHoldersForMethod.put(METHOD_NAME_STR, memberName);
		placeHoldersForMethod.put(METHOD_MODIFIER_STR, modifier);
		placeHoldersForMethod.put(METHOD_ARGS_STR, parameters);
		placeHoldersForMethod.put(METHOD_COMMENTS_STR, EMPTY_STR);
		placeHoldersForMethod.put(METHOD_ANNOTATIONS_STR, EMPTY_STR);
		placeHoldersForMethod.put(METHOD_RETURN_TYPE_STR, returnType);
		//placeHoldersForMethod.put(METHOD_EXCEPTIONS_STR, EMPTY_STR);
		getGlobalSettings(placeHoldersForMethod);
		String methodBody = EMPTY_STR;
		if (type1 != null && type1.exists()) {
			if (type1.isClass()) {
				fullMethodPattern = globalSettings.getClassMethodBody();
			} else if (type1.isInterface()) {
				fullMethodPattern = globalSettings.getInterfaceMethodBody();
			}
		}
		placeHoldersForMethod.put(METHOD_BODY_STR, methodBody);
		methodBody = replacePlaceHolders(methodBody, placeHoldersForMethod);
		if (returnType.equals(METHOD_RETURN_TYPE_VOID)) {
			methodBody = "return;";
		} else if (returnType.equals(INT) || returnType.equals("long") || returnType.equals("short") || returnType.equals(DOUBLE)
				|| returnType.equals(FLOAT)) {
			methodBody = "return 0;";
		} else if (returnType.equals(BOOLEAN)) {
			methodBody = "return false;";
		} else {
			methodBody = "return null;";
		}
		if (!placeHoldersForMethod.containsKey(METHOD_EXCEPTIONS_STR)) {
			fullMethodPattern = replacePlaceHolderWithBlank(fullMethodPattern, "throws", METHOD_EXCEPTIONS_STR, LEFT_CURL);
		}
		fullMethodPattern = replacePlaceHolders(fullMethodPattern, placeHoldersForMethod);
		return fullMethodPattern;
	}

	/**
	 * @param methodName
	 * @param methodSource
	 * @param typeToCreate
	 * @param imports
	 * @param targetFastCodeType.
	 * @param contextMap
	 * @param spacesBeforeCursor
	 * @param compUnit
	 * @param placeHolders
	 * @return
	 * @throws Exception
	 */
	public IMethod createMethodFromTag(final String methodName, final String methodSource, final FastCodeType targetFastCodeType,
			final String typeToCreate, final String imports, final Map<String, Object> contextMap, final String spacesBeforeCursor,
			final Map<String, Object> placeHolders, final ICompilationUnit compUnit) throws Exception {

		IType type = null;
		if (targetFastCodeType.getiType() == null) {
			IJavaProject javaProject = null;
			if (javaProject == null) {
				javaProject = getJavaProject(placeHolders.get(PLACEHOLDER_PROJECT) instanceof FastCodeProject ? ((FastCodeProject) placeHolders
						.get(PLACEHOLDER_PROJECT)).getName() : (String) placeHolders.get(PLACEHOLDER_PROJECT));
			}

			if (javaProject == null) {
				javaProject = getWorkingJavaProjectFromUser();//did for j2ee base
			}
			final FCClassTagHandler fcClassTagHandler = new FCClassTagHandler();
			fcClassTagHandler.createClassFromTag(targetFastCodeType.getName(), targetFastCodeType.getPackage().getName(), javaProject,
					EMPTY_STR, contextMap, placeHolders, compUnit, isEmpty(typeToCreate) ? "class" : typeToCreate, spacesBeforeCursor,
					false, false, false);
			type = ((ICompilationUnit) ((FastCodeObject) contextMap.get("Class_" + targetFastCodeType.getName() + ".java")).getObject())
					.findPrimaryType();
		} else {
			type = targetFastCodeType.getiType();
		}
		type.getCompilationUnit().becomeWorkingCopy(null);
		if (!isEmpty(imports)) {
			for (final String classToImport : imports.split(SPACE)) {
				final FCImportTagHandler fcImportTagHandler = new FCImportTagHandler();
				fcImportTagHandler.createImportFromTag(classToImport, compUnit);
			}
		}
		//type.getCompilationUnit().becomeWorkingCopy(null);

		format(methodSource, spacesBeforeCursor);
		IMethod method = null;
		/*if (isExist) {
			for (final IMethod method1 : type.getMethods()) {
				if (method1.getElementName().equals(methodName)) {
					final IMethod existMethod = type.getMethod(methodName, method1.getParameterTypes());
					existMethod.delete(true, new NullProgressMonitor());
					method = type.createMethod(methodSource, null, false, null);
				}
			}
		} else {*/
		method = type.createMethod(methodSource, null, false, null);
		//}
		if (method == null || !method.exists()) {
			type.getCompilationUnit().discardWorkingCopy();
			throw new Exception("Unable to create method.");
		}

		try {
			final File newFileObj = new File(type.getResource().getLocationURI().toString());
			//final FastCodeCheckinCache checkinCache = FastCodeCheckinCache.getInstance();
			/*addOrUpdateFileStatusInCache(newFileObj);
			//checkinCache.getFilesToCheckIn().add(new FastCodeFileForCheckin(INITIATED, newFileObj.getAbsolutePath()));
			final boolean prjShared = !isEmpty(type.getResource().getProject().getPersistentProperties());
			final boolean prjConfigured = !isEmpty(isPrjConfigured(type.getResource().getProject().getName()));*/
			if ((Boolean) placeHolders.get(AUTO_CHECKIN)) {
				if (proceedWithAutoCheckin(newFileObj, type.getResource().getProject())) {
					final IFile file = (IFile) type.getResource(); //.getLocationURI());
					List<FastCodeEntityHolder> chngsForType = ((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED))
							.get(file); //do contains key
					if (chngsForType == null) {
						chngsForType = new ArrayList<FastCodeEntityHolder>();
						final List<Object> fastCodeMethList = new ArrayList<Object>();
						fastCodeMethList.add(new FastCodeMethod(method));
						chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_METHODS, fastCodeMethList)); //fastCodeCache.getCommentKey().get(fastCodeCache.getCommentKey().indexOf("create.class.field"))
					} else {
						boolean isNew = true;
						Object fastCodeMethList = null;
						for (final FastCodeEntityHolder fcEntityHolder : chngsForType) {
							if (fcEntityHolder.getEntityName().equals(PLACEHOLDER_METHODS)) {
								fastCodeMethList = fcEntityHolder.getFastCodeEntity();
								isNew = false;
								break;
							}
						}

						if (isNew) {
							fastCodeMethList = new ArrayList<Object>();
							((List<Object>) fastCodeMethList).add(new FastCodeMethod(method));
							chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_METHODS, fastCodeMethList));
						} else {
							((List<Object>) fastCodeMethList).add(new FastCodeMethod(method));
						}
					}
					((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED)).put(file, chngsForType);
				}
			}
		} catch (final FastCodeRepositoryException ex) {
			ex.printStackTrace();
		}
		type.getCompilationUnit().commitWorkingCopy(false, null);
		type.getCompilationUnit().discardWorkingCopy();
		return method;
	}
}
