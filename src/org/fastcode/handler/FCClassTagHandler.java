/**
 * This class has been generated by Fast Code Eclipse Plugin
 * For more information please go to http://fast-code.sourceforge.net/
 * @author : Biswarup
 * Created : 09/08/2014 04:11:45
 */
package org.fastcode.handler;

import static org.fastcode.common.FastCodeConstants.AUTO_CHECKIN;
import static org.fastcode.common.FastCodeConstants.COLON;
import static org.fastcode.common.FastCodeConstants.COMMA;
import static org.fastcode.common.FastCodeConstants.DELIMITER;
import static org.fastcode.common.FastCodeConstants.DOT;
import static org.fastcode.common.FastCodeConstants.EMPTY_STR;
import static org.fastcode.common.FastCodeConstants.FC_OBJ_CREATED;
import static org.fastcode.common.FastCodeConstants.FILE_SEPARATOR;
import static org.fastcode.common.FastCodeConstants.FORWARD_SLASH;
import static org.fastcode.common.FastCodeConstants.HASH;
import static org.fastcode.common.FastCodeConstants.INITIATED;
import static org.fastcode.common.FastCodeConstants.JAVA_EXTENSION;
import static org.fastcode.common.FastCodeConstants.NAMES;
import static org.fastcode.common.FastCodeConstants.OPTIONAL;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_CLASS;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_INNERCLASSES;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_NAME;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_PACKAGE;
import static org.fastcode.common.FastCodeConstants.PLACEHOLDER_PROJECT;
import static org.fastcode.common.FastCodeConstants.SPACE;
import static org.fastcode.common.FastCodeConstants.TEMPLATE_TAG_PREFIX;
import static org.fastcode.common.FastCodeConstants.TYPE;
import static org.fastcode.common.FastCodeConstants.XML_START;
import static org.fastcode.popup.actions.snippet.TemplateTagsProcessor.proceedWithAutoCheckin;
import static org.fastcode.util.SourceUtil.buildClass;
import static org.fastcode.util.SourceUtil.createCodeFormatter;
import static org.fastcode.util.SourceUtil.formatCode;
import static org.fastcode.util.SourceUtil.getDefaultPathFromProject;
import static org.fastcode.util.SourceUtil.getFQNameFromFieldTypeName;
import static org.fastcode.util.SourceUtil.getIFileFromFile;
import static org.fastcode.util.SourceUtil.getJavaProject;
import static org.fastcode.util.SourceUtil.getRepositoryServiceClass;
import static org.fastcode.util.SourceUtil.getSuperInterfacesType;
import static org.fastcode.util.SourceUtil.getWorkingJavaProjectFromUser;
import static org.fastcode.util.SourceUtil.implementInterfaceMethods;
import static org.fastcode.util.SourceUtil.overrideBaseClassMethods;
import static org.fastcode.util.StringUtil.isEmpty;
import static org.fastcode.util.StringUtil.isJavaReservedWord;
import static org.fastcode.util.StringUtil.isValidVariableName;
import static org.fastcode.util.StringUtil.parseClassName;
import static org.fastcode.util.StringUtil.replaceSpecialChars;
import static org.fastcode.util.VersionControlUtil.addOrUpdateFileStatusInCache;
import static org.fastcode.util.VersionControlUtil.isPrjConfigured;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.jdt.core.Flags;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IPackageFragment;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.text.edits.ReplaceEdit;
import org.fastcode.common.Action;
import org.fastcode.common.FastCodeConstants.ACTION_ENTITY;
import org.fastcode.common.FastCodeConstants.ACTION_TYPE;
import org.fastcode.common.FastCodeConstants.CLASS_TYPE;
import org.fastcode.common.FastCodeConstants.TemplateTag;
import org.fastcode.common.FastCodeEntityHolder;
import org.fastcode.common.FastCodeObject;
import org.fastcode.common.FastCodePackage;
import org.fastcode.common.FastCodeProject;
import org.fastcode.common.FastCodeType;
import org.fastcode.exception.FastCodeRepositoryException;
import org.fastcode.popup.actions.snippet.TemplateTagsProcessor;
import org.fastcode.preferences.VersionControlPreferences;
import org.fastcode.util.CreateSimilarDescriptorClass;
import org.fastcode.util.FastCodeContext;
import org.fastcode.util.FastCodeFileForCheckin;
import org.fastcode.util.RepositoryService;
import org.fastcode.util.SourceUtil;
import org.fastcode.versioncontrol.FastCodeCheckinCache;

public class FCClassTagHandler implements FCTagHandler {

	@Override
	public Action populateTagAction(final TemplateTag tagFound, final String tagBody, final String insideTagBody,
			final ICompilationUnit compUnit, final boolean hasSubAction1, final Map<String, Object> placeHolders,
			final Map<String, Object> contextMap, final String spacesBeforeCursor, final Map<String, String> attributes,
			final StringBuilder existingMembersBuilder, final List<Action> actionList) throws Exception {
		String memberName = null;
		boolean optional = false;
		final ACTION_TYPE actionType = ACTION_TYPE.Create;
		String typeToCreate = null;
		String delimiter = null;

		if (tagFound == TemplateTag.CLASS) {
			memberName = attributes.containsKey(PLACEHOLDER_NAME) ? attributes.get(PLACEHOLDER_NAME) : null;
		} else if (tagFound == TemplateTag.CLASSES) {
			memberName = attributes.containsKey(NAMES) ? attributes.get(NAMES) : null;
		}
		final String pkg = attributes.containsKey(PLACEHOLDER_PACKAGE) ? attributes.get(PLACEHOLDER_PACKAGE) : EMPTY_STR;
		final String project = attributes.containsKey(PLACEHOLDER_PROJECT) ? attributes.get(PLACEHOLDER_PROJECT) : null;
		typeToCreate = attributes.containsKey(TYPE) ? attributes.get(TYPE) : PLACEHOLDER_CLASS;
		optional = attributes.containsKey(OPTIONAL) ? Boolean.valueOf(attributes.get(OPTIONAL)) : false;
		delimiter = attributes.containsKey(DELIMITER) ? attributes.get(DELIMITER) : SPACE;
		final boolean overrideMethods = attributes.containsKey("override_methods") ? Boolean.valueOf(attributes.get("override_methods"))
				: false;
		/*
		 * IJavaProject prj = getJavaProject(project); if (prj == null) {
		 * prj = getJavaProject((String)
		 * placeHolders.get(PLACEHOLDER_PROJECT)); } if
		 * (prj.getProject().isSynchronized(0)) { throw new
		 * Exception("Project: " + prj.getProject().getName() +
		 * " is not synchronized ,Please refresh and try again."); }
		 */

		if (memberName == null || memberName.equals(EMPTY_STR)) {
			if (tagFound == TemplateTag.CLASS) {
				throw new Exception("Please provide attribute \"name\" for <fc:class> tag in the XML and try again");
			} else if (tagFound == TemplateTag.CLASSES) {
				throw new Exception("Please provide attribute \"names\" for <fc:classes> tag in the XML and try again");
			}
		}
		/*if (pkg == null) {
			throw new Exception("Please provide attribute \"package\" for <fc:" + tagFound.toString().toLowerCase()
					+ "> tag  in the XML and try again");
		}*/
		if (!isEmpty(insideTagBody) && insideTagBody.contains(XML_START + TEMPLATE_TAG_PREFIX + COLON)) {
			throw new Exception("There should not be any other tags inside <fc:" + tagFound.toString().toLowerCase() + ">,  exiting....");
		}
		IJavaProject javaProject = null;

		if (!isEmpty(project) && project.startsWith(HASH)) {
			final Object projct = placeHolders.get(project.replace(HASH, EMPTY_STR).trim());
			if (projct instanceof FastCodeProject) {
				javaProject = ((FastCodeProject) projct).getJavaProject();
				if (javaProject == null) {
					javaProject = getJavaProject(((FastCodeProject) projct).getProject());
				}
			} else {
				javaProject = getJavaProject((String) projct);
			}
		} else {
			javaProject = getJavaProject(project);// getJavaProject(attributes.get(PLACEHOLDER_PROJECT));
		}
		boolean createProject = false;
		if (javaProject == null) {
			for (final Action action : actionList) {
				if (action.getEntity() == ACTION_ENTITY.Project) {
					if (action.getEntityName().equals(project)) {
						javaProject = null;
						createProject = true;
					}
				}
			}
			if (!createProject) {
				javaProject = getJavaProject(placeHolders.get(PLACEHOLDER_PROJECT) instanceof FastCodeProject ? ((FastCodeProject) placeHolders
						.get(PLACEHOLDER_PROJECT)).getName() : (String) placeHolders.get(PLACEHOLDER_PROJECT));
			}
		}
		IPackageFragment pkgFrgmt = null;
		if (!createProject) {
			if (javaProject == null) {
				javaProject = getWorkingJavaProjectFromUser();//did for j2ee base
			}
			final String defaultPath = typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? getDefaultPathFromProject(javaProject,
					typeToCreate, EMPTY_STR) : getDefaultPathFromProject(javaProject, "source", EMPTY_STR);
			final TemplateTagsProcessor templateTagsProcessor = new TemplateTagsProcessor();
			pkgFrgmt = pkg.startsWith(HASH) ? ((FastCodePackage) placeHolders.get(pkg.replace(HASH, EMPTY_STR).trim()))
					.getPackageFragment() : templateTagsProcessor.getPackageFragment(javaProject, defaultPath, pkg,
					typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? typeToCreate : "source");
		}
		String labelMsg = null;
		final String labelMsgPart1 = pkgFrgmt != null ? EMPTY_STR : isEmpty(pkg) ? "default " : "new ";
		boolean isClassExist = false;
		if (tagFound == TemplateTag.CLASS) {
			if (isJavaReservedWord(memberName) || !isValidVariableName(memberName)) {
				throw new Exception(
						"Attribute \"name\" contains either java reserved word or not valid for class name ,Please provide correct one for <fc:class> tag  in the XML and try again");
			}
			if (!isEmpty(insideTagBody)) {
				final String classNameInsideTagBody = parseClassName(replaceSpecialChars(insideTagBody.trim()));
				if (!memberName.equals(classNameInsideTagBody)) {
//					System.out.println(classNameInsideTagBody);
					throw new Exception("Attribute \"name\" value " + memberName + " and class name inside <fc:class> tag body "
							+ classNameInsideTagBody
							+ " does not match, Please provide same name in both the places for <fc:class> tag  in the XML and try again");
				}
			}

			//if (pkgFrgmt != null) {
			final String fullClassName = pkgFrgmt != null ? pkgFrgmt.getElementName() + DOT + memberName.trim() : isEmpty(pkg) ? memberName
					.trim() : pkg + DOT + memberName;

			//if (compUnit != null) {
			if (javaProject != null) {
				final IType type3 = javaProject.findType(fullClassName);
				if (type3 != null && type3.exists()) {
					isClassExist = true;
					/*this.existingMembersBuilder.append("Class with Name:  " + fullClassName);
					this.existingMembersBuilder.append(SPACE + COMMA + SPACE);
					return null;*/
				}
			}
			//}
			//}
			final String pkgNme = pkgFrgmt != null ? pkgFrgmt.getElementName() : pkg;
			final String msg3 = isClassExist ? " (Class already exists.)" : EMPTY_STR;
			final String actionTypeClassLbl = isClassExist ? "Overwrite " : actionType.toString();
			labelMsg = typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? actionTypeClassLbl + SPACE + typeToCreate + SPACE + "class"
					+ SPACE + memberName + "  in " + labelMsgPart1 + "package  " + pkg + msg3 : actionTypeClassLbl + SPACE + typeToCreate
					+ SPACE + memberName + "  in " + labelMsgPart1 + "package  " + pkgNme + msg3; // + msg3;
		} else if (tagFound == TemplateTag.CLASSES) {
			final String[] namesarr = memberName.split(delimiter);
			boolean duplicate = false;
			for (int j = 0; j < namesarr.length; j++) {
				for (int k = j + 1; k < namesarr.length; k++) {
					if (namesarr[k].equals(namesarr[j])) {
						duplicate = true;
						break;
					}
					if (duplicate) {
						break;
					}
				}
			}
			if (duplicate) {
				throw new Exception(
						"Attribute \"names\" contains duplicate class name,Please provide correct  attribute \"names\"  for <fc:classes> tag in the XML and try again");
			}
			//StringBuilder existingClassName = new StringBuilder();
			final List<String> classNamesList = new ArrayList<String>();
			for (final String className : memberName.split(delimiter)) {
				if (isJavaReservedWord(className) || !isValidVariableName(className)) {
					throw new Exception(
							"Attribute \"names\" contains either java reserved word or not valid for class name ,Please provide correct one  for <fc:classes> tag  in the XML and try again");
				}
				classNamesList.add(className);
				//if (pkgFrgmt != null) {
				final String fullClassName = pkgFrgmt != null ? pkgFrgmt.getElementName() + DOT + className.trim()
						: isEmpty(pkg) ? className.trim() : pkg + DOT + className.trim();
				//if (compUnit != null) {
				if (javaProject != null) {
					final IType type4 = javaProject.findType(fullClassName);
					if (type4 != null && type4.exists()) {
						existingMembersBuilder.append("Class with Name:  " + fullClassName);
						existingMembersBuilder.append(SPACE + COMMA + SPACE);
						classNamesList.remove(className);
						continue;
					}
				}
				//}
				//}
			}
			String classNames = EMPTY_STR;
			if (!classNamesList.isEmpty()) {
				for (final String className : classNamesList) {
					classNames = classNames + className + delimiter;

				}
			}
			memberName = classNames;

			if (isEmpty(memberName)) {
				return null;
			}
			labelMsg = typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? actionType.toString() + SPACE + typeToCreate + SPACE
					+ "classes" + SPACE + classNames.replace(delimiter, COMMA + SPACE) + "  in " + labelMsgPart1 + " package  " + pkg
					: actionType.toString() + SPACE + "classes" + SPACE + classNames.replace(delimiter, COMMA + SPACE) + "  in "
							+ labelMsgPart1 + " package  " + pkg;

		}

		final Action actionClass = new Action.Builder()
				.withEntity(tagFound == TemplateTag.CLASS ? ACTION_ENTITY.Class : ACTION_ENTITY.Classes).withType(actionType)
				.withEntityName(memberName).withPackge(pkgFrgmt == null ? pkg : pkgFrgmt)
				.withProject(createProject ? project : javaProject)
				.withSource(isEmpty(insideTagBody) ? insideTagBody : insideTagBody.trim()).withLabelMsg(labelMsg).withOptional(optional)
				.withTypeToCreate(typeToCreate).withDelimiter(delimiter).withOverrideMethods(overrideMethods).withExist(isClassExist)
				.build();

		return actionClass;
		//break;
	}

	/**
	 * @param insideTagBody
	 * @param tagBody
	 * @param templateTag
	 * @param contextMap
	 * @param placeHolders
	 * @param spacesBeforeCursor
	 * @param overrideMethods
	 * @param exist
	 * @param overWrite
	 * @param type
	 * @throws JavaModelException
	 * @throws Exception
	 */
	public void createClassFromTag(final String className, final Object packge, final Object project, String insideTagBody,
			final Map<String, Object> contextMap, final Map<String, Object> placeHolders, final ICompilationUnit compUnit,
			final String typeToCreate, final String spacesBeforeCursor, boolean overrideMethods, final boolean exist,
			final boolean overWrite) throws JavaModelException, Exception {
		final VersionControlPreferences versionControlPreferences = VersionControlPreferences.getInstance();
		if (typeToCreate.equals(ACTION_ENTITY.Innerclass.getValue())) {
			compUnit.becomeWorkingCopy(null);
			final File newFileObj = new File(compUnit.getResource().getLocationURI().toString());
			/*final FastCodeCheckinCache checkinCache = FastCodeCheckinCache.getInstance();
			checkinCache.getFilesToCheckIn().add(new FastCodeFileForCheckin(INITIATED, newFileObj.getAbsolutePath()));*/

			try {
				//addOrUpdateFileStatusInCache(newFileObj);
				final IType innerClassType = SourceUtil.createInnerClass(insideTagBody, compUnit);
				/*final boolean prjShared = !isEmpty(compUnit.getResource().getProject().getPersistentProperties());
				final boolean prjConfigured = !isEmpty(isPrjConfigured(compUnit.getResource().getProject().getName()));*/
				if ((Boolean) placeHolders.get(AUTO_CHECKIN)) {
					if (proceedWithAutoCheckin(newFileObj, compUnit.getResource().getProject())) {
						final IFile file = (IFile) innerClassType.getResource(); //.getLocationURI());
						List<FastCodeEntityHolder> chngsForType = ((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED))
								.get(file);
						if (chngsForType == null) {
							chngsForType = new ArrayList<FastCodeEntityHolder>();
							final List<Object> innerClassList = new ArrayList<Object>();
							innerClassList.add(new FastCodeType(innerClassType));
							chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_INNERCLASSES, innerClassList));
						} else {
							boolean isNew = true;
							Object fastCodeFieldList = null;
							for (final FastCodeEntityHolder fcEntityHolder : chngsForType) {
								if (fcEntityHolder.getEntityName().equals(PLACEHOLDER_INNERCLASSES)) {
									fastCodeFieldList = fcEntityHolder.getFastCodeEntity();
									isNew = false;
									break;
								}
							}

							if (isNew) {
								fastCodeFieldList = new ArrayList<Object>();
								((List<Object>) fastCodeFieldList).add(innerClassType);
								chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_INNERCLASSES, fastCodeFieldList));
							} else {
								((List<Object>) fastCodeFieldList).add(innerClassType);
							}

							/*Object innerClassList = chngsForType.get("innerClasses");
							if (innerClassList == null) {
								innerClassList = new ArrayList<Object>();
							}
							((List<Object>) innerClassList).add(new FastCodeType(innerClassType));
							chngsForType.put("innerClasses", innerClassList);*/
						}
						((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED)).put(file, chngsForType);
					}
				}
			} catch (final FastCodeRepositoryException ex) {
				ex.printStackTrace();
			}
			compUnit.commitWorkingCopy(false, null);
			compUnit.discardWorkingCopy();
			return;
		}

		final IJavaProject prj = project instanceof String ? getJavaProject((String) project) : (IJavaProject) project;
		/*IJavaProject prj = getJavaProject(project);// getJavaProject(attributes.get(PLACEHOLDER_PROJECT));
		if (prj == null) {
			prj = getJavaProject(placeHolders.get(PLACEHOLDER_PROJECT) instanceof FastCodeProject ? ((FastCodeProject) placeHolders
					.get(PLACEHOLDER_PROJECT)).getName() : (String) placeHolders.get(PLACEHOLDER_PROJECT));
		}

		if (prj == null) {
			prj = this.javaProject = this.javaProject == null ? getWorkingJavaProjectFromUser() : this.javaProject;//did for j2ee base
		}*/
		if (prj == null) {
			throw new Exception("Can not continue without java  project.");
		}
		final String srcPath = typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? getDefaultPathFromProject(prj, typeToCreate, EMPTY_STR)
				: getDefaultPathFromProject(prj, "source", EMPTY_STR);
		IPackageFragment pkgFrgmt = null;
		final TemplateTagsProcessor templateTagsProcessor = new TemplateTagsProcessor();
		if (packge instanceof String && !isEmpty((String) packge) || packge instanceof IPackageFragment) {
			pkgFrgmt = packge instanceof String ? templateTagsProcessor.getPackageFragment(prj, srcPath, (String) packge,
					typeToCreate.equals(ACTION_ENTITY.Test.getValue()) ? typeToCreate : "source") : (IPackageFragment) packge;
		}
		if (pkgFrgmt == null) {
			/*final boolean prjShared = !isEmpty(prj.getProject().getPersistentProperties());
			final boolean prjConfigured = !isEmpty(isPrjConfigured(prj.getProject().getName()));*/
			File file = null;
			if ((Boolean) placeHolders.get(AUTO_CHECKIN)) {
				if (proceedWithAutoCheckin(file, prj.getProject())) {
					final String prjURI = prj.getResource().getLocationURI().toString();
					final String path = prjURI.substring(prjURI.indexOf(COLON) + 1);
					final String newPackURL = path + srcPath + FILE_SEPARATOR + ((String) packge).replace(DOT, FILE_SEPARATOR);
					file = new File(newPackURL);
					//final FastCodeCheckinCache checkinCache = FastCodeCheckinCache.getInstance();
					addOrUpdateFileStatusInCache(file);
					//checkinCache.getFilesToCheckIn().add(new FastCodeFileForCheckin(INITIATED, file.getAbsolutePath()));
				}
			}
			pkgFrgmt = templateTagsProcessor.createPackage(prj, (String) packge, typeToCreate, contextMap);// createPackage(prj,
			// attributes.get(PLACEHOLDER_PACKAGE));
			if ((Boolean) placeHolders.get(AUTO_CHECKIN)) {
				if (proceedWithAutoCheckin(null, prj.getProject())) {
					final IFile ifile = getIFileFromFile(file);
					List<FastCodeEntityHolder> chngsForType = ((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED))
							.get(ifile);
					if (chngsForType == null) {
						chngsForType = new ArrayList<FastCodeEntityHolder>();
						chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_PACKAGE, new FastCodePackage(pkgFrgmt)));
					}
					((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED)).put(ifile, chngsForType);
				}
			}
		}

		boolean createFileAlone = true;
		if ((Boolean) placeHolders.get(AUTO_CHECKIN)) {
			String path;
			try {
				final boolean prjShared = !isEmpty(pkgFrgmt.getResource().getProject().getPersistentProperties());
				final boolean prjConfigured = !isEmpty(isPrjConfigured(pkgFrgmt.getResource().getProject().getName()));
				createFileAlone = !(versionControlPreferences.isEnable() && prjShared && prjConfigured);

				final String prjURI = pkgFrgmt.getResource().getLocationURI().toString();
				path = prjURI.substring(prjURI.indexOf(COLON) + 1);
				final File newFileObj = new File(path + FORWARD_SLASH + className + DOT + JAVA_EXTENSION);
				if (versionControlPreferences.isEnable() && prjShared && prjConfigured) {
					final RepositoryService repositoryService = getRepositoryServiceClass();
					try {
						if (repositoryService.isFileInRepository(newFileObj)) { // && !MessageDialog.openQuestion(new Shell(), "File present in repository", "File already present in repository. Click yes to overwrite")) {
							/*MessageDialog.openWarning(new Shell(), "File present in repository", className + " is already present in repository. Please synchronise and try again.");
							return;*/
							createFileAlone = MessageDialog
									.openQuestion(
											new Shell(),
											"File present in repository",
											"File "
													+ newFileObj.getName()
													+ " already present in repository. Click yes to just create the file, No to return without any action.");
							if (!createFileAlone) {
								return;
							}
						}
					} catch (final Throwable th) {
						th.printStackTrace();
						createFileAlone = true;
					}
				}
				final FastCodeCheckinCache checkinCache = FastCodeCheckinCache.getInstance();
				checkinCache.getFilesToCheckIn().add(new FastCodeFileForCheckin(INITIATED, newFileObj.getAbsolutePath()));

			} catch (final FastCodeRepositoryException ex) {
				ex.printStackTrace();
			}
		}

		/*if (parseClassName(insideTagBody) == null) {
			insideTagBody = MODIFIER_PUBLIC + SPACE + typeToCreate + SPACE + className + SPACE + LEFT_CURL + NEWLINE + insideTagBody
					+ NEWLINE + RIGHT_CURL;
		}*/

		final Object codeFormatter = createCodeFormatter(prj.getProject());
		if (!isEmpty(insideTagBody)) {
			insideTagBody = formatCode(insideTagBody.trim(), codeFormatter);
		}
		ICompilationUnit compilationUnit = null;
		if (exist) {
			if (overWrite) {
				final IType type = prj.findType(pkgFrgmt.getElementName() + DOT + className.trim());
				if (type.getCompilationUnit().hasUnsavedChanges()) {
					type.getCompilationUnit().save(new NullProgressMonitor(), true);
				}
				//type.getCompilationUnit().delete(true, new NullProgressMonitor());
				insideTagBody = buildClass(insideTagBody, pkgFrgmt, prj, className);

				//type.getCompilationUnit().getBuffer().setContents(insideTagBody);
				final ReplaceEdit replaceEdit = new ReplaceEdit(0, type.getCompilationUnit().getSource().length(), insideTagBody);
				type.getCompilationUnit().applyTextEdit(replaceEdit, new NullProgressMonitor());
				compilationUnit = type.getCompilationUnit();
				compilationUnit.becomeWorkingCopy(null);
				compilationUnit.commitWorkingCopy(false, null);
				compilationUnit.discardWorkingCopy();

				//refreshProject(prj.getElementName());
			} else {
				return;
			}
		} else {
			compilationUnit = SourceUtil.createClass(insideTagBody, pkgFrgmt, prj, className);
		}

		if (compilationUnit == null) {
			return;
		}
		if (!typeToCreate.equals(ACTION_ENTITY.Interface.getValue())) {
			if (compilationUnit.findPrimaryType().getSuperclassName() != null) {
				final IType superClassType = prj.findType(getFQNameFromFieldTypeName(compilationUnit.findPrimaryType().getSuperclassName(),
						compilationUnit));
				if (superClassType != null && superClassType.exists()) {
					if (Flags.isAbstract(superClassType.getFlags())/*Modifier.isAbstract(Class.forName(superClassType.getFullyQualifiedName()).getModifiers())*/) {
						overrideMethods = true;
					}
				}
			}
			if (overrideMethods) {
				final String superInterfaces[] = compilationUnit.findPrimaryType().getSuperInterfaceNames();
				if (superInterfaces != null) {
					for (final String superInertafce : superInterfaces) {
						final IType superIntType = prj.findType(getFQNameFromFieldTypeName(superInertafce, compilationUnit));
						final FastCodeContext fastCodeContext = new FastCodeContext(superIntType);
						final CreateSimilarDescriptorClass createSimilarDescriptorClass = new CreateSimilarDescriptorClass.Builder()
								.withClassType(CLASS_TYPE.CLASS).build();
						implementInterfaceMethods(superIntType, fastCodeContext, compilationUnit.findPrimaryType(), null,
								createSimilarDescriptorClass);
						final IType[] superInterfaceType = getSuperInterfacesType(superIntType);
						if (superInterfaceType != null) {
							for (final IType type : superInterfaceType) {
								if (type == null || !type.exists()) {
									continue;
								}
								final FastCodeContext context = new FastCodeContext(type);
								implementInterfaceMethods(type, context, compilationUnit.findPrimaryType(), null,
										createSimilarDescriptorClass);
							}
						}
					}
				}
				overrideBaseClassMethods(compilationUnit);
			}
		}
		/*
		 * final IType newType = compilationUnit.findPrimaryType(); String
		 * superClassName = newType.getSuperclassName(); if
		 * (!isEmpty(superClassName)) { final IType superClassType =
		 * prj.findType(getFQNameFromFieldTypeName(newType.getSuperclassName(),
		 * newType.getCompilationUnit())); final FastCodeContext fastCodeContext
		 * = new FastCodeContext(superClassType); final
		 * CreateSimilarDescriptorClass createSimilarDescriptorClass = new
		 * CreateSimilarDescriptorClass.Builder().withClassType(
		 * CLASS_TYPE.CLASS).build(); for (final IMethod method :
		 * superClassType.getMethods()) { if (method.isConstructor()) {
		 * overrideConstructor(method, newType); final MethodBuilder
		 * methodBuilder = new SimilarMethodBuilder(fastCodeContext);
		 * methodBuilder.buildMethod(method, newType, null,
		 * createSimilarDescriptorClass); } } }
		 */
		contextMap.put("Class_" + compilationUnit.getElementName(), new FastCodeObject(compilationUnit, ACTION_ENTITY.Class.getValue()));

		if (!createFileAlone) {
			final IFile fileObj = (IFile) compilationUnit.findPrimaryType().getResource(); //.getLocationURI());
			List<FastCodeEntityHolder> chngsForType = ((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED))
					.get(fileObj);
			if (chngsForType == null) {
				chngsForType = new ArrayList<FastCodeEntityHolder>();
				chngsForType.add(new FastCodeEntityHolder(PLACEHOLDER_CLASS, new FastCodeType(compilationUnit.findPrimaryType())));
			}
			((Map<Object, List<FastCodeEntityHolder>>) contextMap.get(FC_OBJ_CREATED)).put(fileObj, chngsForType);
		}
		/*final Map<String, Object> listofChange = ((Map<Object, Map<String, Object>>) contextMap.get("changes_for_File")).get(file);
		if (chngsForType == null) {
			chngsForType = new HashMap<String, Object>();
			chngsForType.put("class", CREATE_CLASS); //fastCodeCache.getCommentKey().get(fastCodeCache.getCommentKey().indexOf("create.class.field"))
		}
		((Map<Object, Map<String, Object>>) contextMap.get("changes_for_File")).put(file, listofChange);*/
	}
}
